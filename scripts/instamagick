#!/bin/bash

# ================================================================== #
# Script to move images in folders by their 'CreateDate', move       #
# RAF-files into a (new) RAF directory, easily resize and watermark  #
# pictures using ImageMagick, reduce the filesize of pictures        #
# (using mogrify/convert) or PDF files (using ghostscript) and       #
# create timelapses from pictures using ffmpeg. If necessary the     #
# pictures get rotated using exiftran and a backup of the original   #
# file is made by putting a "~" after the extension.                 #
#                                                                    #
#   Call this script and point it to the PATH of the picture         #
#   with the FIRST ARGUMENT after the script call.                   #
#                                                                    #
# Brecht Van Eeckhoudt - 24/09/2020 (development started 22/08/2019) #
# Written on Ubuntu 19.04                                            #
# ================================================================== #

# Version of this script (date)
version="24/09/2020"

# Location of the font to use for watermarking
fontLocation="/home/brecht/.fonts/BebasNeue Book.otf"

# Default watermarking text
watermarkText="@brecht.ve"



# TODO Add ability to change Artist and Copyright fields

# TODO Future improvements:
#  - Check left/right (/bottom) crop functionality for timelapses
#      => 21/09/2020: Changed "ow"/"oh" to "iw"/"ih" for left/right/bottom crop functionality for options 2-6 because "ih" gave problems for 4k bottom timelapse cropping...
#                     Probably needs more testing to be sure, see "Not tested yet!" echo messages!
#  - Simplify resizePicture (and makeTimelapse) code: Use (global, at the top of the file) variables for arguments that always are the same
#  - Add kerning functionality to watermarking text of timelapses (4k = 2.11 // 1440p = 1.51 // insta = 1.01)
#  - Add option to remove metadata (https://superuser.com/questions/450838/exiftool-delete-exif-data-but-preserve-some-specific-tags/450853#450853)
#  - Add option to give a path as an argument/during the execution of the script and move images (0-1), compress pictures (5) and make a timelapse (6)
#      => "Do you want to specify an external path (press enter to execute script here)"
#  - Make sure $foldername can also work if a full path has been given and the script isn't executed in the main directory
#  - Add watermarking functionality to nocrop timelapse options
#  - Add -h and --help script argument
#  - Add watermarking option with PNG's
#  - Add watermarking for 35mm?
#  - Bulk selection? ("-d " argument, DIRECTORY)
#  - Add small white borders to left and right of instagram pictures? (-bordercolor white -border 5x0)



# =================== #
#    MAIN FUNCTION    #
# (gets called at the #
#  end of the script) #
# =================== #

main () {
    # echo "-e" for enabling escape sequences
    # echo "-n" for not advancing to the next line
    #   - "\e[1m"  = bold
    #   - "\e[93m" = light yellow
    #   - "\e[0m"  = reset all attributes
    # read "-p" makes it read as a prompt, meaning it doesn't add a trailing newline before trying to read input.
    # read "-r" (raw) tells read to not treat backslashes specially

    # Set IFS to an empty string to retain leading and trailing whitespace when using "read"
    IFS=

    echo -e "\n\e[1m\e[93mInstaMagick // Comprehensive image manipulation script.\e[0m"
    echo -e "\e[93m   Makes use of ImageMagick (and convert and mogrify),"
    echo    "   ghostscript, ffmpeg, exiftool and exiftran."
    echo -e "\e[1mBrecht Van Eeckhoudt ($version)\e[0m\n"
    echo -e "\e[93m<<< Press \e[1mENTER\e[0m\e[93m to choose default value and \e[1mCTRL + C\e[0m\e[93m to quit >>>\n"
    
    echo -e "\e[93mWhat do you want to do?"
    echo "  Options: '0' = Move images in new directories based on their 'CreateDate'"
    echo "           '1' = Move RAF files into a (new) RAF directory"
    echo "           '2' = Read all metadata of a file (ImageCount, ...)"
    echo "           '3' = Read important metadata of an image (short)"
    echo "           '4' = Resize picture and optionally add a watermark (text)"
    echo "           '5' = Compress picture(s)"
    echo "           '6' = Compress PDF document"
    echo "           '7' = Create a timelapse"
    read -p $'Selected option: \e[0m' selection

    case $selection in
        # Move images in new directories based on their 'CreateDate'
        #   -DateTimeOriginal = time of shutter actuation
        #   -CreateDate = time of file write to memory card
        '0')
            read -p $'\n\e[93m  What is the extension of the images? (default = \e[0mJPG\e[93m) \e[0m' extension

            # Check if an argument was given, if not: use default JPG extension (-z = string is null, has zero length)
            if [ -z "$extension" ]; then extension="JPG"; fi

            echo -e "\n\e[93mMoving images... \e[0m"

            # Move pictures in new directories based on their CreateDate (-r = run recursively)
            exiftool '-Directory<CreateDate' -d ./%Y-%m-%d -r *.$extension

            echo -e "\e[93mDone!\e[0m\n"
            ;;

        # Move RAF files into a (new) RAF directory
        '1')
            echo -n -e "\n\e[93mMoving files... \e[0m"

            mkdir RAF; mv *.RAF RAF

            echo -e "\e[93mDone! All of the RAF files are moved to the directory '\e[0mRAF\e[93m'.\e[0m\n"
            ;;
        
        # Read metadata of a file
        '2')
            # Check if an input filepath was given and if not ask for one ("$@" = pass arguments from script call)
            checkInput "$@"

            echo -e "\n\e[93mRead metadata:\e[0m"

            # -g = Show the group names (g1 shows the family 1 group name (ie. the location) of each tag)
            # -a = Allow duplicate tags to be extracted
            # --UserComment = Exclude tag from extracted information
            # TODO unused arguments (kept here just in case):
            #   -v = Verbose
            #   -s = Show the tag names instead of their descriptions (short) (-s2 is a compact version of this, -s3 only returns the value itself)
            #   -S = very short notation
            exiftool -g -a --UserComment "$filepath"

            # Read UserComment metadata-field
            readUserComment=$(exiftool -s3 -UserComment "$filepath")

            if [ -n "$readUserComment"  ] # Check if UserComment contains data (-n = string is not null)
            then
                echo -e "---- UserComment ----"
                exiftool -b -UserComment "$filepath" # Read only UserComment in binary format (makes \n work...)
            fi

            echo # Blank line
            ;;
        
        # Read important metadata of an image
        '3')
            # Check if an input filepath was given and if not ask for one ("$@" = pass arguments from script call)
            checkInput "$@"

            # Read MakerNoteFujiFilm
            readMakerNotes=$(exiftool -MakerNotes:ImageCount -MakerNotes:Quality -MakerNotes:ImageGeneration -MakerNotes:ShutterType -MakerNotes:WhiteBalance -MakerNotes:WhiteBalanceFineTune -MakerNotes:FilmMode -MakerNotes:HighlightTone -MakerNotes:ShadowTone -MakerNotes:Saturation -MakerNotes:ColorChromeEffect -MakerNotes:GrainEffect -MakerNotes:BWAdjustment -MakerNotes:Sharpness -MakerNotes:NoiseReduction -MakerNotes:DevelopmentDynamicRange "$filepath")

            # Read CreateDate, Artist, Copyright, Software and FocalLength
            readInfo=$(exiftool -CreateDate -Artist -Copyright -Software -FocalLength "$filepath")

            # Read metadata (-s3 = only display value)
            readModel=$(exiftool -s3 -Model "$filepath")
            readLensModel=$(exiftool -s3 -LensModel "$filepath")
            readISO=$(exiftool -s3 -ISO "$filepath")
            readExposureTime=$(exiftool -s3 -ExposureTime "$filepath")
            readFNumber=$(exiftool -s3 -FNumber "$filepath")

            echo -e "\n\e[93mMakerNotes:\e[0m"
            echo    "$readMakerNotes"
            echo -e "\n\e[93mBasic metadata:\e[0m"
            echo -e "$readInfo\n"
            echo    "$readModel with $readLensModel"
            echo -e "ISO $readISO, ${readExposureTime}s, F$readFNumber\n"
            ;;

        # Resizing pictures (with/without watermarking)
        '4')
            # Check if an input filepath was given and if not ask for one ("$@" = pass arguments from script call)
            checkInput "$@"

            # Call logic
            resizePicture
            ;;

        # Compressing pictures
        '5')
            echo -e "\n\e[93mDo you want to compress all of the pictures in the directory?"
            echo "  Options: 'y' = Yes"
            echo "           'n' = No (default)"
            read -p $'Selected option: \e[0m' resizing

            # Check the given argument and set boolean value and other settings accordingly
            case $resizing in
                # Yes
                'y'|'Y')
                    read -p $'\n\e[93m  What is the extension of the images? (default = \e[0mJPG\e[93m) \e[0m' extension

                    # Check if an argument was given, if not: use default JPG extension (-z = string is null, has zero length)
                    if [ -z "$extension" ]; then extension="JPG"; fi
                    
                    read -p $'\n\e[93m  What should the reduction factor be? (0 - 100 (%), default = \e[0m85\e[93m%) \e[0m' reduction
 
                    # Check if an argument was given, if not: use default value of 85 (-z = string is null, has zero length)
                    if [ -z "$reduction" ]; then reduction=85; fi

                    echo -n -e "\n\e[93mConverting... \e[0m"

                    mkdir compressed; mogrify -path compressed -format $extension -resize $reduction% *.$extension
                    
                    echo -e "\e[93mDone! The converted files are in the directory '\e[0mcompressed\e[93m'.\e[0m\n"
                    ;;
                
                # No ('' = enter without character)
                ''|'n'|'N')
                    # Check if an input filepath was given and if not ask for one ("$@" = pass arguments from script call)
                    checkInput "$@"

                    read -p $'\n\e[93m  What should the reduction factor be? (0 - 100 (%), default = \e[0m85\e[93m%) \e[0m' reduction

                    # Check if an argument was given, if not: use default value of 85 (-z = string is null, has zero length)
                    if [ -z "$reduction" ]; then reduction=85; fi

                    echo -n -e "\n\e[93mConverting... \e[0m"

                    convert -resize $reduction%  $filepath "$filename"-compressed.$extension # Quote marks so spaces can exist in the filepath

                    echo -e "\e[93mDone! Converted file: \e[0m$filename-compressed.$extension\n"
                    ;;

                # Unknown option
                *)
                    echo -e "\n\e[91mERROR: Unknown option selected. Goodbye!\e[0m"
                    ;;
            esac
            ;;

        # Compress PDF document
        '6')
            # Check if an input filepath was given and if not ask for one ("$@" = pass arguments from script call)
            checkInput "$@"

            echo -n -e "\n\e[93mConverting... \e[0m"

            gs -sDEVICE=pdfwrite -dCompatibilityLevel=1.4 -dNOPAUSE -dQUIET -dBATCH -dPrinted=false -dPDFSETTINGS=/prepress \
                -sOutputFile="$filename"-compressed.$extension "$filepath" # Quote marks so spaces can exist in the filepath

            echo -e "\e[93mDone! Converted file: \e[0m$filename-compressed.$extension\n"
            ;;

        # Timelapse creation
        '7')
            # Call logic
            makeTimelapse
            ;;
        
        # Unkown option
        *)
            echo -e "\e[91mERROR: Unknown option selected. Goodbye!\e[0m\n"
            ;;
    esac
}


# ========================================== #
# FUNCTION TO ADD METADATA TO TIMELAPSE FILE #
# ========================================== #

checkMetadata () {
    extraMetadataGiven=false

    # TODO When metadata needs to be copied over using ffmpeg: -movflags use_metadata_tags = allow custom tags (kept here just in case)
    # ffmpeg -i input.mp4 -movflags use_metadata_tags -metadata newTag="newTag" output.mp4

    # TODO MakerNotes can only be transferred as a whole block (between images) and make/model also has to be copied over! (kept here just in case)
    # exiftool -tagsFromFile input.jpg -makernotes -make -model output.jpg

    echo -e "\n\e[93mDo you want to add extra metadata-info? (location, time between each shot,...)"
    read -r -p $'  Press enter if not, otherwise enter text: \e[0m' extraMetadata

    # Check if an argument was given (-n = string is not null)
    if [ -n "$extraMetadata" ]; then extraMetadataGiven=true; fi

    # Read CreateDate from first image of timelapse (-s3 = only return value itself)
    readCreateDate=$(exiftool -s3 -CreateDate "$firstImage")

    # Read Make and Model from first image of timelapse
    readMakeModel=$(exiftool -Make -Model "$firstImage")

    # Read ISO and ExposureTime (~ ShutterSpeedValue) from first image of timelapse
    readISOExposureTime=$(exiftool -ISO -ExposureTime "$firstImage")

    echo -e "\n\e[93mIs the following other metadata correct?"
    echo -e "Press enter if true, otherwise enter text to replace current value.\e[0m"

    # Read FNumber (~ ApertureValue) from first image of timelapse (-s3 = only return value itself)   
    readFNumber=$(exiftool -s3 -FNumber "$firstImage")
    echo -e -n "\e[93m  readFNumber (\e[0m"$readFNumber"\e[93m): \e[0m"
    read -r checkFNumber

    # Check if an argument was given (-n = string is not null), if true: updata data
    if [ -n "$checkFNumber" ]; then readFNumber="$checkFNumber"; fi

    # Read FocalLength from first image of timelapse (-s3 = only return value itself)
    readFocalLength=$(exiftool -s3 -FocalLength "$firstImage")
    echo -e -n "\e[93m  FocalLength (\e[0m"$readFocalLength"\e[93m): \e[0m"
    read -r checkFocalLength

    # Check if an argument was given (-n = string is not null), if true: updata data
    if [ -n "$checkFocalLength" ]; then readFocalLength="$checkFocalLength"; fi

    # Read LensMake from first image of timelapse (-s3 = only return value itself)
    readLensMake=$(exiftool -s3 -LensMake "$firstImage")
    echo -e -n "\e[93m  LensMake    (\e[0m"$readLensMake"\e[93m): \e[0m"
    read -r checkLensMake

    # Check if an argument was given (-n = string is not null), if true: updata data
    if [ -n "$checkLensMake" ]; then readLensMake="$checkLensMake"; fi

    # Read LensModel from first image of timelapse (-s3 = only return value itself)
    readLensModel=$(exiftool -s3 -LensModel "$firstImage")
    echo -e -n "\e[93m  LensModel   (\e[0m"$readLensModel"\e[93m): \e[0m"
    read -r checkLensModel

    # Check if an argument was given (-n = string is not null), if true: updata data
    if [ -n "$checkLensModel" ]; then readLensModel="$checkLensModel"; fi

    # Read MakerNoteFujiFilm data from first image of timelapse
    readMakerNotes=$(exiftool -MakerNotes:Quality -MakerNotes:ShutterType -MakerNotes:WhiteBalance -MakerNotes:WhiteBalanceFineTune -MakerNotes:FilmMode -MakerNotes:HighlightTone -MakerNotes:ShadowTone -MakerNotes:Saturation -MakerNotes:ColorChromeEffect -MakerNotes:GrainEffect -MakerNotes:BWAdjustment -MakerNotes:Sharpness -MakerNotes:NoiseReduction -MakerNotes:DevelopmentDynamicRange "$firstImage")

    NL=$'\n' # Allow ${NL} to be used in quoted strings

    if [ "$extraMetadataGiven" = true ] # Boolean check
    then
        newUserComment="$extraMetadata${NL}Start date/time of timelapse    : $readCreateDate${NL}$readMakeModel${NL}LensMake                        : $readLensMake${NL}LensModel                       : $readLensModel${NL}FocalLength                     : $readFocalLength${NL}FNumber                         : $readFNumber${NL}$readISOExposureTime${NL}$readMakerNotes${NL}"
    else
        newUserComment="Start date/time of timelapse    : $readCreateDate${NL}$readMakeModel${NL}LensMake                        : $readLensMake${NL}LensModel                       : $readLensModel${NL}FocalLength                     : $readFocalLength${NL}FNumber                         : $readFNumber${NL}$readISOExposureTime${NL}$readMakerNotes${NL}"
    fi

    echo -e "\n\e[93mAdding the following metadata to the videofile:\e[0m"
    echo "$newUserComment"

    echo -n -e "\e[93mAdding metadata to file... \e[0m"

    # Transfer over Artist and Copyright tags and add new UserComment info (quote marks so spaces can exist in the filepath)
    exiftool -overwrite_original -tagsFromFile "$firstImage" -Artist -Copyright -UserComment="$newUserComment" "$outputFile"
}


# ============================== #
# FUNCTION TO CHECK ASPECT RATIO #
#                                #
#   If the input and output      #
#   aspect ratio are NOT the     #
#   same this will ask for a     #
#   "gravity" option.            #
#                                #
#   Arguments:                   #
#     - $1 = input width         #
#     - $2 = input height        #
#     - $3 = output width        #
#     - $4 = output height       #
# ============================== #

# Default "gravity" option
selectedGravity="center"

checkAspectRatio () {
    # "bc" used for floating point arithmetic, "scale=2" = required precision
    # "* 100 / 1" for later integer comparasion

    # TODO: This doesn't seem necessary (kept here just in case)
    #inputRatio=$(echo "scale=2 ; $1 / $2" | bc)
    #inputRatio=$(echo "$inputRatio * 100 / 1" | bc)
    #outputRatio=$(echo "scale=2 ; $3 / $4" | bc)
    #outputRatio=$(echo "$outputRatio * 100 / 1" | bc)
    #
    #echo DEBUG: inputRatio = $inputRatio
    #echo DEBUG: outputRatio = $outputRatio
    # TODO: End uneccesary code

    # Calculate the ratio's of the width and height to determine what needs to be cut
    widthRatio=$(echo "scale=2 ; $1 / $3" | bc)
    widthRatio=$(echo "$widthRatio * 100 / 1" | bc)
    heightRatio=$(echo "scale=2 ; $2 / $4" | bc)
    heightRatio=$(echo "$heightRatio * 100 / 1" | bc)

    # Ask for a "gravity" used to crop the picture if the ratio's don't match
    # Double brackets to activate the aritmetic context
    if (( widthRatio != heightRatio ))
    then

        # We can crop from the top, center or bottom
        if (( widthRatio < heightRatio ))
        then
            echo -e "\e[93mIn- and output aspect-ratio are not the same!"
            echo "Please select a direction to crop the picture."
            echo "  Options: 't' = Top"
            echo "           'c' = Center (default)"
            echo "           'b' = Bottom"

            # "$" to enable the use of the color escape sequence
            read -p $'Selected option: \e[0m' gravity

            case $gravity in
                # Top
                't'|'T')
                    selectedGravity="north"
                    ;;

                # Center ('' = enter without character)
                ''|'c'|'C')
                    selectedGravity="center"
                    ;;

                # Bottom
                'b'|'B')
                    selectedGravity="south"
                    ;;
                
                # Unkown option
                *)
                    echo -e "\e[91mERROR: Unknown option selected. Using default value (center).\e[0m"
                    ;;
            esac

        # We can crop from the left, center and right
        else
            echo -e "\e[93mIn- and output aspect-ratio are not the same!"
            echo "Please select a direction to crop the picture."
            echo "  Options: 'l' = Left"
            echo "           'c' = Center (default)"
            echo "           'r' = Right"    

            # "$" to enable the use of the color escape sequence
            read -p $'Selected option: \e[0m' gravity

            case $gravity in
                # Left
                'l'|'L')
                    selectedGravity="west"
                    ;;

                # Center ('' = enter without character)
                ''|'c'|'C')
                    selectedGravity="center"
                    ;;

                # Right
                'r'|'R')
                    selectedGravity="east"
                    ;;

                # Unkown option
                *)
                    echo -e "\e[91mERROR: Unknown option selected. Using default value (center).\e[0m"
                    ;;
            esac

        fi

        echo # Blank line
    fi
}


# ========================================================================= #
# FUNCTION TO ASK FOR INPUT FILEPATH IF NO ARGUMENT IS GIVEN ON SCRIPT CALL #
# ========================================================================= #

checkInput () {
    if [ -z "$1" ] # "$1" = First argument given after the script call (-z = string is null, has zero length)
    then
        echo -e "\n\e[93mNo path to a file given as the argument of this script!"
        read -r -p $'  Please do so now: \e[0m' filepath

        # Check if there are quote marks in the given file path (' or ")
        # Check if first character matches
        if [[ ${filepath:0:1} = "'" || ${filepath:0:1} = "\"" ]]
        then
            # Check if last character matches (space is necessary!)
            if [[ ${filepath: -1} = "'" || ${filepath: -1} = "\"" ]]
            then
                # Remove first and last character
                filepath="${filepath:1:-1}"
            fi
        fi
    else
        filepath="$1" # Quote marks so spaces can exist in the filepath
    fi

    # Split filename and extension (quote marks so spaces can exist in the filepath)
    filename="${filepath##*/}"
    filename="${filename%.*}"
    extension="${filepath##*.}"
}


# ========================= #
# FUNCTION TO SET WATERMARK #
# ========================= #

checkWatermark () {
    watermarking=false # Default to no watermark

    echo -e "\n\e[93mDo you want to enable the watermark? (text)"
    echo "  Options: 'y' = Yes"
    echo "           'n' = No (default)"
    echo "           'c' = Select custom color and opacity"
    read -p $'Selected option: \e[0m' watermark

    # Check the given argument and set boolean value and other settings accordingly
    case $watermark in
        # Yes
        'y'|'Y')
            watermarking=true
            watermarkColor="rgba(169,169,169,0.50)"
            watermarkColorTimelapse="0xA9A9A9@0.50"
            echo -e "\e[93m  Using the default watermark options: color = \e[0mDark grey \e[93mopacity = \e[0m0.50"
            ;;
        
        # No ('' = enter without character)
        ''|'n'|'N')
            # watermarking=false
            ;;

        # Custom
        'c'|'C')
            watermarking=true

            echo -e "\n\e[93mWhat color do you want for the watermark?"
            echo "  Options: '0' = Dark grey (default)"
            echo "           '1' = White"
            echo "           '2' = Black"
            read -p $'Selected option: \e[0m' color

            read -p $'\n\e[93mWhat should the opacity be? (0.00 - 1.00, default = \e[0m0.50\e[93m) \e[0m' opacity

            # Check if an argument was given, if not: use default value of 0.50 (-z = string is null, has zero length)
            if [ -z "$opacity" ]; then opacity=0.50; fi

            case $color in
                # Dark grey ('' = enter without character)
                ''|'0')
                    watermarkColor="rgba(169,169,169,$opacity)"
                    watermarkColorTimelapse="0xA9A9A9@$opacity"
                    echo -e "\e[93m  Using the color \e[0mDark grey \e[93mwith an opacity of \e[0m$opacity"
                    ;;

                # White
                '1')
                    watermarkColor="rgba(255,255,255,$opacity)"
                    watermarkColorTimelapse="white@$opacity"
                    echo -e "\e[93m  Using the color \e[0mWhite \e[93mwith an opacity of \e[0m$opacity"
                    ;;

                # Black
                '2')
                    watermarkColor="rgba(0,0,0,$opacity)"
                    watermarkColorTimelapse="black@$opacity"
                    echo -e "\e[93m  Using the color \e[0mBlack \e[93mwith an opacity of \e[0m$opacity"
                    ;;
                
                # Unkown option
                *)
                    watermarkColor="rgba(169,169,169,0.50)" # Default (dark grey)
                    watermarkColorTimelapse="0xA9A9A9@$opacity"
                    echo -e "\e[91mERROR: Unknown option selected. Using default color (dark grey) and opacity (0.50).\e[0m"
                    ;;
            esac
            ;;
        
        # Unknown option
        *)
            echo -e "\e[91mERROR: Unknown option selected. No watermark is added.\e[0m"
            # watermarking=false
            ;;
    esac

    if [ "$watermarking" = true ] # Boolean check
    then
        echo -e "\n\e[93mDo you need a custom watermark text? (default = \e[0m$watermarkText\e[93m)"
        read -r -p $'  Press enter if not, otherwise enter text: \e[0m' watermarkChangeText

        # Check if an argument was given (-n = string is not null), if true: updata data
        if [ -n "$watermarkChangeText" ]; then watermarkText="$watermarkChangeText"; fi
    fi

    echo # Blank line
}


# =========================== #
# FUNCTION TO MAKE TIMELAPSES #
# =========================== #

makeTimelapse () {
    read -p $'\n\e[93m  What is the extension of the images? (default = \e[0mJPG\e[93m) \e[0m' extension

    # Check if an argument was given, if not: use default JPG extension (-z = string is null, has zero length)
    if [ -z "$extension" ]; then extension="JPG"; fi

    read -p $'\n\e[93m  What should the framerate be? (default = \e[0m30\e[93mfps) \e[0m' framerate

    # Check if an argument was given, if not: use default value of 30 fps (-z = string is null, has zero length)
    if [ -z "$framerate" ]; then framerate=30; fi

    # Call watermark logic
    checkWatermark

    echo -e "\e[93mWhat output size do you need?"
    echo "  Options: '0' = 4k    (16:9) [3840x2160]"
    echo "                 (no crop and upscaling, add black bars where needed)"
    echo "           '1' = 1440p (16:9) [2560x1440]"
    echo "                 (no crop and upscaling, add black bars where needed)"
    echo # Blank line
    echo "           '2' = 4k    (16:9) [3840x2160]"
    echo "           '3' = 1440p (16:9) [2560x1440] (default)"
    echo # Blank line
    echo "           '4' = Insta (1:1)  [1080x1080]"
    echo "           '5' = Insta (4:5)  [1080x1350]"
    echo "           '6' = Insta (5:4)  [1080x566]"
    read -p $'Selected option: \e[0m' videoSize
    echo # Blank line

    # Store array ($firstImage will give back the first item)
    firstImage=(*.$extension)

    echo -e "\e[93mTaking size/metadata-information from first picture (\e[0m$firstImage\e[93m)\e[0m\n"

    # Get image rotation ("-ping" to not load the entire image)
    orientation=$(identify -ping -format '%[orientation]' "$firstImage") # Quote marks so spaces can exist in the filepath

    # Rotate images if necessary
    if [ "$orientation" = "LeftBottom" ] ||  [ "$orientation" = "BottomRight" ] || [ "$orientation" = "RightTop" ]  
    then
        echo -e "\e[93mRotating images... \e[0m"

        exiftran -apib *.$extension # a = automatic, p = preserve timestamps, i = inplace editing, b = create backup file (add "~" after each original file)

        echo # Blank line
    fi

    # Check input dimensions ("-ping" to not load the entire image)
    width=$(identify -ping -format '%w' "$firstImage") # Quote marks so spaces can exist in the filepath 
    height=$(identify -ping -format '%h' "$firstImage") # Quote marks so spaces can exist in the filepath

    # Variable to see if we need pwd to get the foldername
    execPWD=true

    # Check if there are "/" marks in the given file path
    case "$filepath" in 
        */*)
            execPWD=false # TODO Uneccesary (for now?) because no path can be given to the timelapse functionality
            ;;
    esac

    if [ "$execPWD" = true ]; then foldername="$(pwd)"; fi

    # Get directory (quote marks so spaces can exist in the path)
    foldername="${foldername##*/}"
    
    case $videoSize in
        # 4k (16:9) [3840x2160] (no crop and upscaling, add black bars where needed)
        0)
            echo -e "\e[93mConverting... \e[0m"

            if [ "$watermarking" = true ] # Boolean check
            then
                # TODO Watermarking placement depends on black bars! First watermark and then add black bars?

                echo -e "\e[91mERROR: Currently no watermarking is supported for this mode, its placement depends on the size of the black bars. Goodbye!\e[0m\n"

            else
                outputFile="$foldername-4k-${framerate}fps-nocrop.mp4"

                ffmpeg -r $framerate -pattern_type glob -i "*.$extension" -vcodec libx264 -crf 20 -pix_fmt yuv420p -tune film \
                    -vf "scale='min(3840,iw)':min'(2160,ih)':force_original_aspect_ratio=decrease,pad=3840:2160:(ow-iw)/2:(oh-ih)/2" "$outputFile"
            fi
            ;;

        # 1440p (16:9) [2560x1440] (no crop and upscaling, add black bars where needed)
        1)
            echo -n -e "\e[93mConverting... \e[0m"

            if [ "$watermarking" = true ] # Boolean check
            then
                # TODO Watermarking placement depends on black bars! First watermark and then add black bars?

                echo -e "\e[91mERROR: Currently no watermarking is supported for this mode, its placement depends on the size of the black bars. Goodbye!\e[0m\n"

            else
                outputFile="$foldername-1440p-${framerate}fps-nocrop.mp4"

                ffmpeg -r $framerate -pattern_type glob -i "*.$extension" -vcodec libx264 -crf 20 -pix_fmt yuv420p -tune film \
                    -vf "scale='min(2560,iw)':min'(1440,ih)':force_original_aspect_ratio=decrease,pad=2560:1440:(ow-iw)/2:(oh-ih)/2" "$outputFile"
            fi
            ;;

        # 4k (16:9) [3840x2160]
        2)
            # Check if the aspect ratio's match and ask for a "gravity" option if not the case
            checkAspectRatio $width $height 3840 2160

            echo -e "\e[93mConverting... \e[0m"

            if [ "$watermarking" = true ] # Boolean check
            then
                outputFile="$foldername-4k-${framerate}fps-wm.mp4"
            else
                outputFile="$foldername-4k-${framerate}fps.mp4"
            fi

            case $selectedGravity in
                # Left
                "west") # TODO not yet tested!
                    echo -e "\e[91mNot yet tested!\e[0m\n"

                    if [ "$watermarking" = true ] # Boolean check
                    then
                        ffmpeg -r $framerate -pattern_type glob -i "*.$extension" -vcodec libx264 -crf 20 -pix_fmt yuv420p -tune film \
                            -vf "scale=3840:2160:force_original_aspect_ratio=increase,crop=3840:2160:-iw:0,drawtext=text=\'$watermarkText\':x=20:y=H-th-16:fontfile=\'$fontLocation\':fontsize=40:fontcolor=$watermarkColorTimelapse" "$outputFile"
                    else
                        ffmpeg -r $framerate -pattern_type glob -i "*.$extension" -vcodec libx264 -crf 20 -pix_fmt yuv420p -tune film \
                            -vf "scale=3840:2160:force_original_aspect_ratio=increase,crop=3840:2160:-iw:0" "$outputFile"
                    fi
                    ;;

                # Top
                "north")
                    if [ "$watermarking" = true ] # Boolean check
                    then
                        ffmpeg -r $framerate -pattern_type glob -i "*.$extension" -vcodec libx264 -crf 20 -pix_fmt yuv420p -tune film \
                            -vf "scale=3840:2160:force_original_aspect_ratio=increase,crop=3840:2160:0:0,drawtext=text=\'$watermarkText\':x=20:y=H-th-16:fontfile=\'$fontLocation\':fontsize=40:fontcolor=$watermarkColorTimelapse" "$outputFile"
                    else                        
                        ffmpeg -r $framerate -pattern_type glob -i "*.$extension" -vcodec libx264 -crf 20 -pix_fmt yuv420p -tune film \
                            -vf "scale=3840:2160:force_original_aspect_ratio=increase,crop=3840:2160:0:0" "$outputFile"
                    fi
                    ;;

                # Center
                "center")
                    if [ "$watermarking" = true ] # Boolean check
                    then
                        ffmpeg -r $framerate -pattern_type glob -i "*.$extension" -vcodec libx264 -crf 20 -pix_fmt yuv420p -tune film \
                            -vf "scale=3840:2160:force_original_aspect_ratio=increase,crop=3840:2160,drawtext=text=\'$watermarkText\':x=20:y=H-th-16:fontfile=\'$fontLocation\':fontsize=40:fontcolor=$watermarkColorTimelapse" "$outputFile"

                    else
                        ffmpeg -r $framerate -pattern_type glob -i "*.$extension" -vcodec libx264 -crf 20 -pix_fmt yuv420p -tune film \
                            -vf "scale=3840:2160:force_original_aspect_ratio=increase,crop=3840:2160" "$outputFile"       
                    fi
                    ;;

                # Right
                "east") # TODO not yet tested!
                    echo -e "\e[91mNot yet tested!\e[0m\n"

                    if [ "$watermarking" = true ] # Boolean check
                    then
                        ffmpeg -r $framerate -pattern_type glob -i "*.$extension" -vcodec libx264 -crf 20 -pix_fmt yuv420p -tune film \
                            -vf "scale=3840:2160:force_original_aspect_ratio=increase,crop=3840:2160:iw:0,drawtext=text=\'$watermarkText\':x=20:y=H-th-16:fontfile=\'$fontLocation\':fontsize=40:fontcolor=$watermarkColorTimelapse" "$outputFile"
                    else
                        ffmpeg -r $framerate -pattern_type glob -i "*.$extension" -vcodec libx264 -crf 20 -pix_fmt yuv420p -tune film \
                            -vf "scale=3840:2160:force_original_aspect_ratio=increase,crop=3840:2160:iw:0" "$outputFile"
                    fi
                    ;;

                # Bottom
                "south")
                    if [ "$watermarking" = true ] # Boolean check
                    then
                        ffmpeg -r $framerate -pattern_type glob -i "*.$extension" -vcodec libx264 -crf 20 -pix_fmt yuv420p -tune film \
                            -vf "scale=3840:2160:force_original_aspect_ratio=increase,crop=3840:2160:0:ih,drawtext=text=\'$watermarkText\':x=20:y=H-th-16:fontfile=\'$fontLocation\':fontsize=40:fontcolor=$watermarkColorTimelapse" "$outputFile"
                    else
                        ffmpeg -r $framerate -pattern_type glob -i "*.$extension" -vcodec libx264 -crf 20 -pix_fmt yuv420p -tune film \
                            -vf "scale=3840:2160:force_original_aspect_ratio=increase,crop=3840:2160:0:ih" "$outputFile"
                    fi
                    ;;
            esac
            ;;

        # 1440p (16:9) [2560x1440] (default) ('' = enter without character)
        ''|3)
            # Check if the aspect ratio's match and ask for a "gravity" option if not the case
            checkAspectRatio $width $height 2560 1440

            echo -e "\e[93mConverting... \e[0m"

            if [ "$watermarking" = true ] # Boolean check
            then
                outputFile="$foldername-1440p-${framerate}fps-wm.mp4"
            else
                outputFile="$foldername-1440p-${framerate}fps.mp4"
            fi

            case $selectedGravity in
                # Left
                "west") # TODO not yet tested!
                    echo -e "\e[91mNot yet tested!\e[0m\n"

                    if [ "$watermarking" = true ] # Boolean check
                    then
                        ffmpeg -r $framerate -pattern_type glob -i "*.$extension" -vcodec libx264 -crf 20 -pix_fmt yuv420p -tune film \
                            -vf "scale=2560:1440:force_original_aspect_ratio=increase,crop=2560:1440:-iw:0,drawtext=text=\'$watermarkText\':x=13:y=H-th-10:fontfile=\'$fontLocation\':fontsize=27:fontcolor=$watermarkColorTimelapse" "$outputFile"
                    else
                        ffmpeg -r $framerate -pattern_type glob -i "*.$extension" -vcodec libx264 -crf 20 -pix_fmt yuv420p -tune film \
                            -vf "scale=2560:1440:force_original_aspect_ratio=increase,crop=2560:1440:-iw:0" "$outputFile"
                    fi
                    ;;

                # Top
                "north")
                    if [ "$watermarking" = true ] # Boolean check
                    then
                        ffmpeg -r $framerate -pattern_type glob -i "*.$extension" -vcodec libx264 -crf 20 -pix_fmt yuv420p -tune film \
                            -vf "scale=2560:1440:force_original_aspect_ratio=increase,crop=2560:1440:0:0,drawtext=text=\'$watermarkText\':x=13:y=H-th-10:fontfile=\'$fontLocation\':fontsize=27:fontcolor=$watermarkColorTimelapse" "$outputFile"
                        
                    else
                        ffmpeg -r $framerate -pattern_type glob -i "*.$extension" -vcodec libx264 -crf 20 -pix_fmt yuv420p -tune film \
                            -vf "scale=2560:1440:force_original_aspect_ratio=increase,crop=2560:1440:0:0" "$outputFile"
                    fi
                    ;;

                # Center
                "center")
                    if [ "$watermarking" = true ] # Boolean check
                    then
                        ffmpeg -r $framerate -pattern_type glob -i "*.$extension" -vcodec libx264 -crf 20 -pix_fmt yuv420p -tune film \
                            -vf "scale=2560:1440:force_original_aspect_ratio=increase,crop=2560:1440,drawtext=text=\'$watermarkText\':x=13:y=H-th-10:fontfile=\'$fontLocation\':fontsize=27:fontcolor=$watermarkColorTimelapse" "$outputFile"
                    else
                        ffmpeg -r $framerate -pattern_type glob -i "*.$extension" -vcodec libx264 -crf 20 -pix_fmt yuv420p -tune film \
                            -vf "scale=2560:1440:force_original_aspect_ratio=increase,crop=2560:1440" "$outputFile"
                    fi
                    ;;
                
                # Right
                "east") # TODO not yet tested!
                    echo -e "\e[91mNot yet tested!\e[0m\n"

                    if [ "$watermarking" = true ] # Boolean check
                    then
                        ffmpeg -r $framerate -pattern_type glob -i "*.$extension" -vcodec libx264 -crf 20 -pix_fmt yuv420p -tune film \
                            -vf "scale=2560:1440:force_original_aspect_ratio=increase,crop=2560:1440:iw:0,drawtext=text=\'$watermarkText\':x=13:y=H-th-10:fontfile=\'$fontLocation\':fontsize=27:fontcolor=$watermarkColorTimelapse" "$outputFile"
                    else
                        ffmpeg -r $framerate -pattern_type glob -i "*.$extension" -vcodec libx264 -crf 20 -pix_fmt yuv420p -tune film \
                            -vf "scale=2560:1440:force_original_aspect_ratio=increase,crop=2560:1440:iw:0" "$outputFile"
                    fi
                    ;;

                # Bottom
                "south")
                    if [ "$watermarking" = true ] # Boolean check
                    then
                        ffmpeg -r $framerate -pattern_type glob -i "*.$extension" -vcodec libx264 -crf 20 -pix_fmt yuv420p -tune film \
                            -vf "scale=2560:1440:force_original_aspect_ratio=increase,crop=2560:1440:0:ih,drawtext=text=\'$watermarkText\':x=13:y=H-th-10:fontfile=\'$fontLocation\':fontsize=27:fontcolor=$watermarkColorTimelapse" "$outputFile"
                    else
                        ffmpeg -r $framerate -pattern_type glob -i "*.$extension" -vcodec libx264 -crf 20 -pix_fmt yuv420p -tune film \
                            -vf "scale=2560:1440:force_original_aspect_ratio=increase,crop=2560:1440:0:ih" "$outputFile"
                    fi
                    ;;
            esac
            ;;

        # Insta (1:1) [1080x1080]
        4)
            # Check if the aspect ratio's match and ask for a "gravity" option if not the case
            checkAspectRatio $width $height 1080 1080

            echo -e "\e[93mConverting... \e[0m"

            if [ "$watermarking" = true ] # Boolean check
            then
                outputFile="$foldername-insta-1x1-${framerate}fps-wm.mp4"
            else
                outputFile="$foldername-insta-1x1-${framerate}fps.mp4"
            fi

            case $selectedGravity in
                # Left
                "west") 
                    if [ "$watermarking" = true ] # Boolean check
                    then
                        ffmpeg -r $framerate -pattern_type glob -i "*.$extension" -vcodec libx264 -crf 20 -pix_fmt yuv420p -tune film \
                            -vf "scale=1080:1080:force_original_aspect_ratio=increase,crop=1080:1080:-iw:0,drawtext=text=\'$watermarkText\':x=9:y=H-th-10:fontfile=\'$fontLocation\':fontsize=30:fontcolor=$watermarkColorTimelapse" "$outputFile"
                    else
                        ffmpeg -r $framerate -pattern_type glob -i "*.$extension" -vcodec libx264 -crf 20 -pix_fmt yuv420p -tune film \
                            -vf "scale=1080:1080:force_original_aspect_ratio=increase,crop=1080:1080:-iw:0" "$outputFile"
                    fi
                    ;;
                
                # Top
                "north")
                    if [ "$watermarking" = true ] # Boolean check
                    then
                        ffmpeg -r $framerate -pattern_type glob -i "*.$extension" -vcodec libx264 -crf 20 -pix_fmt yuv420p -tune film \
                            -vf "scale=1080:1080:force_original_aspect_ratio=increase,crop=1080:1080:0:0,drawtext=text=\'$watermarkText\':x=9:y=H-th-10:fontfile=\'$fontLocation\':fontsize=30:fontcolor=$watermarkColorTimelapse" "$outputFile"
                    else
                        ffmpeg -r $framerate -pattern_type glob -i "*.$extension" -vcodec libx264 -crf 20 -pix_fmt yuv420p -tune film \
                            -vf "scale=1080:1080:force_original_aspect_ratio=increase,crop=1080:1080:0:0" "$outputFile"
                    fi
                    ;;

                # Center
                "center")
                    if [ "$watermarking" = true ] # Boolean check
                    then
                        ffmpeg -r $framerate -pattern_type glob -i "*.$extension" -vcodec libx264 -crf 20 -pix_fmt yuv420p -tune film \
                            -vf "scale=1080:1080:force_original_aspect_ratio=increase,crop=1080:1080,drawtext=text=\'$watermarkText\':x=9:y=H-th-10:fontfile=\'$fontLocation\':fontsize=30:fontcolor=$watermarkColorTimelapse" "$outputFile"
                    else
                        ffmpeg -r $framerate -pattern_type glob -i "*.$extension" -vcodec libx264 -crf 20 -pix_fmt yuv420p -tune film \
                            -vf "scale=1080:1080:force_original_aspect_ratio=increase,crop=1080:1080" "$outputFile"
                    fi
                    ;;
                
                # Right
                "east")
                    if [ "$watermarking" = true ] # Boolean check
                    then
                        ffmpeg -r $framerate -pattern_type glob -i "*.$extension" -vcodec libx264 -crf 20 -pix_fmt yuv420p -tune film \
                            -vf "scale=1080:1080:force_original_aspect_ratio=increase,crop=1080:1080:iw:0,drawtext=text=\'$watermarkText\':x=9:y=H-th-10:fontfile=\'$fontLocation\':fontsize=30:fontcolor=$watermarkColorTimelapse" "$outputFile"
                    else
                        ffmpeg -r $framerate -pattern_type glob -i "*.$extension" -vcodec libx264 -crf 20 -pix_fmt yuv420p -tune film \
                            -vf "scale=1080:1080:force_original_aspect_ratio=increase,crop=1080:1080:iw:0" "$outputFile"
                    fi
                    ;;

                # Bottom
                "south")
                    if [ "$watermarking" = true ] # Boolean check
                    then
                        ffmpeg -r $framerate -pattern_type glob -i "*.$extension" -vcodec libx264 -crf 20 -pix_fmt yuv420p -tune film \
                            -vf "scale=1080:1080:force_original_aspect_ratio=increase,crop=1080:1080:0:ih,drawtext=text=\'$watermarkText\':x=9:y=H-th-10:fontfile=\'$fontLocation\':fontsize=30:fontcolor=$watermarkColorTimelapse" "$outputFile"
                    else
                        ffmpeg -r $framerate -pattern_type glob -i "*.$extension" -vcodec libx264 -crf 20 -pix_fmt yuv420p -tune film \
                            -vf "scale=1080:1080:force_original_aspect_ratio=increase,crop=1080:1080:0:ih" "$outputFile"
                    fi
                    ;;
            esac
            ;;
        
        # Insta (4:5) [1080x1350]
        5)
            # Check if the aspect ratio's match and ask for a "gravity" option if not the case
            checkAspectRatio $width $height 1080 1350

            echo -e "\e[93mConverting... \e[0m"

            if [ "$watermarking" = true ] # Boolean check
            then
                outputFile="$foldername-insta-4x5-${framerate}fps-wm.mp4"
            else
                outputFile="$foldername-insta-4x5-${framerate}fps.mp4"
            fi

            case $selectedGravity in
                # Left
                "west")
                    if [ "$watermarking" = true ] # Boolean check
                    then
                        ffmpeg -r $framerate -pattern_type glob -i "*.$extension" -vcodec libx264 -crf 20 -pix_fmt yuv420p -tune film \
                            -vf "scale=1080:1350:force_original_aspect_ratio=increase,crop=1080:1350:-iw:0,drawtext=text=\'$watermarkText\':x=9:y=H-th-10:fontfile=\'$fontLocation\':fontsize=30:fontcolor=$watermarkColorTimelapse" "$outputFile"
                    else
                        ffmpeg -r $framerate -pattern_type glob -i "*.$extension" -vcodec libx264 -crf 20 -pix_fmt yuv420p -tune film \
                            -vf "scale=1080:1350:force_original_aspect_ratio=increase,crop=1080:1350:-iw:0" "$outputFile"
                    fi
                    ;;
                
                # Top
                "north")
                    if [ "$watermarking" = true ] # Boolean check
                    then
                        ffmpeg -r $framerate -pattern_type glob -i "*.$extension" -vcodec libx264 -crf 20 -pix_fmt yuv420p -tune film \
                            -vf "scale=1080:1350:force_original_aspect_ratio=increase,crop=1080:1350:0:0,drawtext=text=\'$watermarkText\':x=9:y=H-th-10:fontfile=\'$fontLocation\':fontsize=30:fontcolor=$watermarkColorTimelapse" "$outputFile"
                    else
                        ffmpeg -r $framerate -pattern_type glob -i "*.$extension" -vcodec libx264 -crf 20 -pix_fmt yuv420p -tune film \
                            -vf "scale=1080:1350:force_original_aspect_ratio=increase,crop=1080:1350:0:0" "$outputFile"
                    fi
                    ;;

                # Center
                "center")
                    if [ "$watermarking" = true ] # Boolean check
                    then
                        ffmpeg -r $framerate -pattern_type glob -i "*.$extension" -vcodec libx264 -crf 20 -pix_fmt yuv420p -tune film \
                            -vf "scale=1080:1350:force_original_aspect_ratio=increase,crop=1080:1350,drawtext=text=\'$watermarkText\':x=9:y=H-th-10:fontfile=\'$fontLocation\':fontsize=30:fontcolor=$watermarkColorTimelapse" "$outputFile"
                    else
                        ffmpeg -r $framerate -pattern_type glob -i "*.$extension" -vcodec libx264 -crf 20 -pix_fmt yuv420p -tune film \
                            -vf "scale=1080:1350:force_original_aspect_ratio=increase,crop=1080:1350" "$outputFile"
                    fi
                    ;;
                
                # Right
                "east")
                    if [ "$watermarking" = true ] # Boolean check
                    then
                        ffmpeg -r $framerate -pattern_type glob -i "*.$extension" -vcodec libx264 -crf 20 -pix_fmt yuv420p -tune film \
                            -vf "scale=1080:1350:force_original_aspect_ratio=increase,crop=1080:1350:iw:0,drawtext=text=\'$watermarkText\':x=9:y=H-th-10:fontfile=\'$fontLocation\':fontsize=30:fontcolor=$watermarkColorTimelapse" "$outputFile"
                    else
                        ffmpeg -r $framerate -pattern_type glob -i "*.$extension" -vcodec libx264 -crf 20 -pix_fmt yuv420p -tune film \
                            -vf "scale=1080:1350:force_original_aspect_ratio=increase,crop=1080:1350:iw:0" "$outputFile"
                    fi
                    ;;

                # Bottom
                "south")
                    if [ "$watermarking" = true ] # Boolean check
                    then
                        ffmpeg -r $framerate -pattern_type glob -i "*.$extension" -vcodec libx264 -crf 20 -pix_fmt yuv420p -tune film \
                            -vf "scale=1080:1350:force_original_aspect_ratio=increase,crop=1080:1350:0:ih,drawtext=text=\'$watermarkText\':x=9:y=H-th-10:fontfile=\'$fontLocation\':fontsize=30:fontcolor=$watermarkColorTimelapse" "$outputFile"
                    else
                        ffmpeg -r $framerate -pattern_type glob -i "*.$extension" -vcodec libx264 -crf 20 -pix_fmt yuv420p -tune film \
                            -vf "scale=1080:1350:force_original_aspect_ratio=increase,crop=1080:1350:0:ih" "$outputFile"
                    fi
                    ;;
            esac
            ;;

        # Insta (5:4) [1080x566]
        6)
            # Check if the aspect ratio's match and ask for a "gravity" option if not the case
            checkAspectRatio $width $height 1080 566

            echo -e "\e[93mConverting... \e[0m"

            if [ "$watermarking" = true ] # Boolean check
            then
                outputFile="$foldername-insta-5x4-${framerate}fps-wm.mp4"
            else
                outputFile="$foldername-insta-5x4-${framerate}fps.mp4"
            fi

            case $selectedGravity in
                # Left
                "west") # TODO not yet tested!
                    echo -e "\e[91mNot yet tested!\e[0m\n"

                    if [ "$watermarking" = true ] # Boolean check
                    then
                        ffmpeg -r $framerate -pattern_type glob -i "*.$extension" -vcodec libx264 -crf 20 -pix_fmt yuv420p -tune film \
                            -vf "scale=1080:566:force_original_aspect_ratio=increase,crop=1080:566:-iw:0,drawtext=text=\'$watermarkText\':x=9:y=H-th-10:fontfile=\'$fontLocation\':fontsize=30:fontcolor=$watermarkColorTimelapse" "$outputFile"
                    else
                        ffmpeg -r $framerate -pattern_type glob -i "*.$extension" -vcodec libx264 -crf 20 -pix_fmt yuv420p -tune film \
                            -vf "scale=1080:566:force_original_aspect_ratio=increase,crop=1080:566:-iw:0" "$outputFile"
                    fi
                    ;;
                
                # Top
                "north")
                    if [ "$watermarking" = true ] # Boolean check
                    then
                        ffmpeg -r $framerate -pattern_type glob -i "*.$extension" -vcodec libx264 -crf 20 -pix_fmt yuv420p -tune film \
                            -vf "scale=1080:566:force_original_aspect_ratio=increase,crop=1080:566:0:0,drawtext=text=\'$watermarkText\':x=9:y=H-th-10:fontfile=\'$fontLocation\':fontsize=30:fontcolor=$watermarkColorTimelapse" "$outputFile"
                    else
                        ffmpeg -r $framerate -pattern_type glob -i "*.$extension" -vcodec libx264 -crf 20 -pix_fmt yuv420p -tune film \
                            -vf "scale=1080:566:force_original_aspect_ratio=increase,crop=1080:566:0:0" "$outputFile"
                    fi
                    ;;

                # Center
                "center")
                    if [ "$watermarking" = true ] # Boolean check
                    then
                        ffmpeg -r $framerate -pattern_type glob -i "*.$extension" -vcodec libx264 -crf 20 -pix_fmt yuv420p -tune film \
                            -vf "scale=1080:566:force_original_aspect_ratio=increase,crop=1080:566,drawtext=text=\'$watermarkText\':x=9:y=H-th-10:fontfile=\'$fontLocation\':fontsize=30:fontcolor=$watermarkColorTimelapse" "$outputFile"
                    else
                        ffmpeg -r $framerate -pattern_type glob -i "*.$extension" -vcodec libx264 -crf 20 -pix_fmt yuv420p -tune film \
                            -vf "scale=1080:566:force_original_aspect_ratio=increase,crop=1080:566" "$outputFile"
                    fi
                    ;;
                
                # Right
                "east") # TODO not yet tested!
                    echo -e "\e[91mNot yet tested!\e[0m\n"

                    if [ "$watermarking" = true ] # Boolean check
                    then
                        ffmpeg -r $framerate -pattern_type glob -i "*.$extension" -vcodec libx264 -crf 20 -pix_fmt yuv420p -tune film \
                            -vf "scale=1080:566:force_original_aspect_ratio=increase,crop=1080:566:iw:0,drawtext=text=\'$watermarkText\':x=9:y=H-th-10:fontfile=\'$fontLocation\':fontsize=30:fontcolor=$watermarkColorTimelapse" "$outputFile"
                    else
                        ffmpeg -r $framerate -pattern_type glob -i "*.$extension" -vcodec libx264 -crf 20 -pix_fmt yuv420p -tune film \
                            -vf "scale=1080:566:force_original_aspect_ratio=increase,crop=1080:566:iw:0" "$outputFile"
                    fi
                    ;;

                # Bottom
                "south")
                    if [ "$watermarking" = true ] # Boolean check
                    then
                        ffmpeg -r $framerate -pattern_type glob -i "*.$extension" -vcodec libx264 -crf 20 -pix_fmt yuv420p -tune film \
                            -vf "scale=1080:566:force_original_aspect_ratio=increase,crop=1080:566:0:ih,drawtext=text=\'$watermarkText\':x=9:y=H-th-10:fontfile=\'$fontLocation\':fontsize=30:fontcolor=$watermarkColorTimelapse" "$outputFile"
                    else
                        ffmpeg -r $framerate -pattern_type glob -i "*.$extension" -vcodec libx264 -crf 20 -pix_fmt yuv420p -tune film \
                            -vf "scale=1080:566:force_original_aspect_ratio=increase,crop=1080:566:0:ih" "$outputFile"
                    fi
                    ;;
            esac
            ;;

        # Unknown option
        *)
            echo -e "\e[91mERROR: Unknown option selected. Goodbye!\e[0m\n"
            ;;
    esac

    if [ "$videoSize" = '' ] || [ "$videoSize" = '0' ] ||  [ "$videoSize" = '1' ] || [ "$videoSize" = '2' ] || [ "$videoSize" = '3' ] \
                             || [ "$videoSize" = '4' ] || [ "$videoSize" = '5' ] || [ "$videoSize" = '6' ]
    then
        # Call metadata logic
        checkMetadata

        echo -e "\n\e[93mDone! Created file: \e[0m$outputFile\n"
    fi
}


# ===================================== #
# FUNCTION TO RESIZE/WATERMARK PICTURES #
# ===================================== #

resizePicture () {
    # Call watermark logic
    checkWatermark

    echo -e "\e[93mWhat output size do you need?"
    echo "  Options: '0' = 4k    (16:9)  [3840x2160]"
    echo "           '1' = 1440p (16:9)  [2560x1440] (default)"
    echo "           '2' = 1080p (16:9)  [1920x1080]"
    echo # Blank line
    echo "           '3' = Insta (1:1)   [1080x1080]"
    echo "           '4' = Insta (1:1)   [1080x1080] (fit and add white borders)"
    echo "           '5' = Insta (1:1)   [1080x1080] (fit and add white borders)"
    echo "                         (other watermark for analog scanned pictures)"
    echo "           '6' = Insta 2x(1:1) [2160x1080] (divide in two halves)"
    echo # Blank line
    echo "           '7' = Insta (4:5)   [1080x1350]"
    echo "           '8' = Insta (4:5)   [1080x1350] (fit and add white borders)"
    echo "           '9' = Insta (4:5)   [1080x1350] (fit and add white borders)"
    echo "                         (other watermark for analog scanned pictures)"
    echo "          '10' = Insta 2x(4:5) [2160x1350] (divide in two halves)"
    echo # Blank line
    echo "          '11' = Insta (5:4)   [1080x566]"
    echo # Blank line
    echo "          '12' = 35mm  (3:2)   [N/A] (no watermark)"
    echo "          '13' = 35mm  (2:3)   [N/A] (no watermark)"
    read -p $'Selected option: \e[0m' option
    echo # Blank line

    # Get image rotation ("-ping" to not load the entire image)
    orientation=$(identify -ping -format '%[orientation]' "$filepath") # Quote marks so spaces can exist in the filepath

    # Rotate images if necessary
    if [ "$orientation" = "LeftBottom" ] ||  [ "$orientation" = "BottomRight" ] || [ "$orientation" = "RightTop" ]  
    then
        echo -n -e "\e[93mRotating image... \e[0m"

        exiftran -apib "$filepath" # a = automatic, p = preserve timestamps, i = inplace editing, b = create backup file (add "~" after each original file)

        echo # Blank line
    fi

    # Check input dimensions ("-ping" to not load the entire image)
    width=$(identify -ping -format '%w' "$filepath") # Quote marks so spaces can exist in the filepath
    height=$(identify -ping -format '%h' "$filepath") # Quote marks so spaces can exist in the filepath

    case $option in
        # 4k (16:9) [3840x2160] (40pt watermark / kerning 2.11 -annotate +20+8)
        0)
            # Check if the aspect ratio's match and ask for a "gravity" option if not the case
            checkAspectRatio $width $height 3840 2160

            echo -n -e "\e[93mConverting... \e[0m"

            if [ "$watermarking" = true ] # Boolean check
            then
                outputFile="$filename-4k-wm.jpg"

                # "$filepath" Quote marks so spaces can exist in the filepath
                # Resize flags:
                #   - ">" = Only shrink larger images
                #   - "^"  = Resize the image based on the smallest fitting dimension so it'll completely fill (and even overflow) the pixel area given
                # "+repage" = Reset dimensions of image virtual canvas to the actual image itself after cropping for the annotation to work correctly
                # "-kerning 2.11" = Slightly more space between characters
                convert -quality 100 "$filepath" \
                    -resize '3840x2160^' -gravity $selectedGravity -crop '3840x2160+0+0' +repage \
                    -pointsize 40 -font "$fontLocation" -kerning 2.11 -fill $watermarkColor \
                    -gravity SouthWest -annotate +20+8 "$watermarkText" "$outputFile"
            else
                outputFile="$filename-4k.jpg"

                convert -quality 100 "$filepath" -resize '3840x2160^' -gravity $selectedGravity -crop '3840x2160+0+0' "$outputFile"
            fi
            ;;

        # 1440p (16:9) [2560x1440] (27pt watermark / kerning 1.51 -annotate +13+5)
        ''|1)
            # Check if the aspect ratio's match and ask for a "gravity" option if not the case
            checkAspectRatio $width $height 2560 1440

            echo -n -e "\e[93mConverting... \e[0m"

            if [ "$watermarking" = true ] # Boolean check
            then
                outputFile="$filename-1440p-wm.jpg"

                convert -quality 100 "$filepath" \
                    -resize '2560x1440^' -gravity $selectedGravity -crop '2560x1440+0+0' +repage \
                    -pointsize 27 -font "$fontLocation" -kerning 1.51 -fill $watermarkColor \
                    -gravity SouthWest -annotate +13+5 "$watermarkText" "$outputFile"
            else
                outputFile="$filename-1440p.jpg"

                convert -quality 100 "$filepath" -resize '2560x1440^' -gravity $selectedGravity -crop '2560x1440+0+0' "$outputFile"
            fi
            ;;

        # 1080p (16:9) [1920x1080] (20pt watermark / kerning 1.01 -annotate +10+4)
        2)
            # Check if the aspect ratio's match and ask for a "gravity" option if not the case
            checkAspectRatio $width $height 1920 1080

            echo -n -e "\e[93mConverting... \e[0m"

            if [ "$watermarking" = true ] # Boolean check
            then
                outputFile="$filename-1080p-wm.jpg"

                convert -quality 100 "$filepath" \
                    -resize '1920x1080^' -gravity $selectedGravity -crop '1920x1080+0+0' +repage \
                    -pointsize 20 -font "$fontLocation" -kerning 1.01 -fill $watermarkColor \
                    -gravity SouthWest -annotate +10+4 "$watermarkText" "$outputFile"
            else
                outputFile="$filename-1080p.jpg"

                convert -quality 100 "$filepath" -resize '1920x1080^' -gravity $selectedGravity -crop '1920x1080+0+0' "$outputFile"
            fi
            ;;

        # Insta (1:1) [1080x1080]
        3)
            # Check if the aspect ratio's match and ask for a "gravity" option if not the case
            checkAspectRatio $width $height 1080 1080

            echo -n -e "\e[93mConverting... \e[0m"

            if [ "$watermarking" = true ] # Boolean check
            then
                outputFile="$filename-insta-1x1-wm.jpg"

                convert -quality 100 "$filepath" \
                    -resize '1080x1080^' -gravity $selectedGravity -crop '1080x1080+0+0' +repage \
                    -pointsize 30 -font "$fontLocation" -kerning 1.01 -fill $watermarkColor \
                    -gravity SouthWest -annotate +9+4 "$watermarkText" "$outputFile"
            else
                outputFile="$filename-insta-1x1.jpg"

                convert -quality 100 "$filepath" -resize '1080x1080^' -gravity $selectedGravity -crop '1080x1080+0+0' "$outputFile"
            fi
            ;;

        # Insta (1:1) [1080x1080] (fit and add white borders)
        4)
            # Calculate the ratio's of the width and height to determine where we need to add white borders
            widthRatio=$(echo "scale=2 ; $width / 1080" | bc)
            widthRatio=$(echo "$widthRatio * 100 / 1" | bc)
            heightRatio=$(echo "scale=2 ; $height / 1080" | bc)
            heightRatio=$(echo "$heightRatio * 100 / 1" | bc)

            echo -n -e "\e[93mConverting... \e[0m"

            if [ "$watermarking" = true ] # Boolean check
            then
                outputFile="$filename-insta-1x1-nocrop-wm.jpg"
            else
                outputFile="$filename-insta-1x1-nocrop.jpg"
            fi

            # Add white borders to the left and right (double brackets to activate the aritmetic context)
            if (( widthRatio < heightRatio ))
            then
                if [ "$watermarking" = true ] # Boolean check
                then
                    # First resize to picture with HEIGHT of 1080 (x1080), then watermark, then add borders
                    convert -quality 100 "$filepath" \
                        -resize x1080 \
                        -pointsize 30 -font "$fontLocation" -kerning 1.01 -fill $watermarkColor \
                        -gravity SouthWest -annotate +9+4 "$watermarkText" +repage \
                        -gravity center -background white -extent '1080x1080' "$outputFile"
                else
                    convert -quality 100 "$filepath" -resize x1080 -gravity center -background white -extent '1080x1080' "$outputFile"
                fi

            # Add white border to the top and bottom
            else
                if [ "$watermarking" = true ] # Boolean check
                then
                    # First resize to picture with WIDTH of 1080, then watermark, then add borders
                    convert -quality 100 "$filepath" \
                        -resize 1080 \
                        -pointsize 30 -font "$fontLocation" -kerning 1.01 -fill $watermarkColor \
                        -gravity SouthWest -annotate +9+4 "$watermarkText" +repage \
                        -gravity center -background white -extent '1080x1080'"$outputFile"
                else
                    convert -quality 100 "$filepath" -resize 1080 -gravity center -background white -extent '1080x1080' "$outputFile"
                fi
            fi
            ;;

        # Insta (1:1) [1080x1080] (fit and add white borders) (other watermark for analog scanned pictures)
        5)
            # Calculate the ratio's of the width and height to determine where we need to add white borders
            widthRatio=$(echo "scale=2 ; $width / 1080" | bc)
            widthRatio=$(echo "$widthRatio * 100 / 1" | bc)
            heightRatio=$(echo "scale=2 ; $height / 1080" | bc)
            heightRatio=$(echo "$heightRatio * 100 / 1" | bc)

            echo -n -e "\e[93mConverting... \e[0m"

            if [ "$watermarking" = true ] # Boolean check
            then
                outputFile="$filename-insta-1x1-nocrop-wm.jpg"
            else
                outputFile="$filename-insta-1x1-nocrop.jpg"
            fi

            # Add white borders to the left and right (double brackets to activate the aritmetic context)
            if (( widthRatio < heightRatio ))
            then
                if [ "$watermarking" = true ] # Boolean check
                then
                    # First resize to picture with HEIGHT of 1080 (x1080), then watermark, then add borders
                    convert -quality 100 "$filepath" \
                        -resize x1080 \
                        -pointsize 25 -font "$fontLocation" -kerning 1.01 -fill $watermarkColor \
                        -gravity SouthWest -annotate +25+32 "$watermarkText" +repage \
                        -gravity center -background white -extent '1080x1080' "$outputFile"
                else
                    convert -quality 100 "$filepath" -resize x1080 -gravity center -background white -extent '1080x1080' "$outputFile"
                fi

            # Add white border to the top and bottom
            else
                if [ "$watermarking" = true ] # Boolean check
                then
                    # First resize to picture with WIDTH of 1080, then watermark, then add borders
                    convert -quality 100 "$filepath" \
                        -resize 1080 \
                        -pointsize 25 -font "$fontLocation" -kerning 1.01 -fill $watermarkColor \
                        -gravity SouthWest -annotate +38+20 "$watermarkText" +repage \
                        -gravity center -background white -extent '1080x1080' "$outputFile"
                else
                    convert -quality 100 "$filepath" -resize 1080 -gravity center -background white -extent '1080x1080' "$outputFile"
                fi
            fi
            ;;

        # Insta 2x(1:1) [2160x1080] (divide in two halves)
        6)
            # Check if the aspect ratio's match and ask for a "gravity" option if not the case
            checkAspectRatio $width $height 2160 1080

            echo -n -e "\e[93mConverting... \e[0m"

            if [ "$watermarking" = true ] # Boolean check
            then
                outputFile="$filename-insta-1x1-wide-wm.jpg"

                # First resize to big picture, then divide in two, then watermark 
                # "@" = Equally divide the image into the number of tiles generated
                # "+gravity" = reset gravity option
                convert -quality 100 "$filepath" \
                    -resize '2160x1080^' -gravity $selectedGravity -crop '2160x1080+0+0' +repage \
                    +gravity -crop 2x1@ +repage \
                    -pointsize 30 -font "$fontLocation" -kerning 1.01 -fill $watermarkColor \
                    -gravity SouthWest -annotate +9+4 "$watermarkText" "$outputFile"
            else
                outputFile="$filename-insta-1x1-wide.jpg"

                convert -quality 100 "$filepath" -resize '2160x1080^' -gravity $selectedGravity \
                    -crop '2160x1080+0+0' +repage +gravity -crop 2x1@ +repage "$outputFile"
            fi
            ;;

        # Insta (4:5) [1080x1350]
        7)
            # Check if the aspect ratio's match and ask for a "gravity" option if not the case
            checkAspectRatio $width $height 1080 1350

            echo -n -e "\e[93mConverting... \e[0m"

            if [ "$watermarking" = true ] # Boolean check
            then
                outputFile="$filename-insta-4x5-wm.jpg"

                convert -quality 100 "$filepath" \
                    -resize '1080x1350^' -gravity $selectedGravity -crop '1080x1350+0+0' +repage \
                    -pointsize 30 -font "$fontLocation" -kerning 1.01 -fill $watermarkColor \
                    -gravity SouthWest -annotate +9+4 "$watermarkText" "$outputFile"
            else
                outputFile="$filename-insta-4x5.jpg"

                convert -quality 100 "$filepath" -resize '1080x1350^' -gravity $selectedGravity -crop '1080x1350+0+0' "$outputFile"
            fi
            ;;

        # Insta (4:5) [1080x1350] (fit and add white borders)
        8)
            # Calculate the ratio's of the width and height to determine where we need to add white borders
            widthRatio=$(echo "scale=2 ; $width / 1080" | bc)
            widthRatio=$(echo "$widthRatio * 100 / 1" | bc)
            heightRatio=$(echo "scale=2 ; $height / 1350" | bc)
            heightRatio=$(echo "$heightRatio * 100 / 1" | bc)

            echo -n -e "\e[93mConverting... \e[0m"

            if [ "$watermarking" = true ] # Boolean check
            then
                outputFile="$filename-insta-4x5-nocrop-wm.jpg"
            else
                outputFile="$filename-insta-4x5-nocrop.jpg"
            fi

            # Add white borders to the left and right (double brackets to activate the aritmetic context)
            if (( widthRatio < heightRatio ))
            then
                if [ "$watermarking" = true ] # Boolean check
                then
                    # First resize to picture with HEIGHT of 1350 (x1350), then watermark, then add borders
                    convert -quality 100 "$filepath" \
                        -resize x1350 \
                        -pointsize 30 -font "$fontLocation" -kerning 1.01 -fill $watermarkColor \
                        -gravity SouthWest -annotate +9+4 "$watermarkText" +repage \
                        -gravity center -background white -extent '1080x1350' "$outputFile"
                else
                    convert -quality 100 "$filepath" -resize x1350 -gravity center -background white -extent '1080x1350' "$outputFile"
                fi

            # Add white border to the top and bottom
            else
                if [ "$watermarking" = true ] # Boolean check
                then
                    # First resize to picture with WIDTH of 1080, then watermark, then add borders
                    convert -quality 100 "$filepath" \
                        -resize 1080 \
                        -pointsize 30 -font "$fontLocation" -kerning 1.01 -fill $watermarkColor \
                        -gravity SouthWest -annotate +9+4 "$watermarkText" +repage \
                        -gravity center -background white -extent '1080x1350' "$outputFile"
                else
                    convert -quality 100 "$filepath" -resize 1080 -gravity center -background white -extent '1080x1350' "$outputFile"
                fi
            fi
            ;;

        # Insta (4:5) [1080x1350] (fit and add white borders) (other watermark for analog scanned pictures)
        9)
            # Calculate the ratio's of the width and height to determine where we need to add white borders
            widthRatio=$(echo "scale=2 ; $width / 1080" | bc)
            widthRatio=$(echo "$widthRatio * 100 / 1" | bc)
            heightRatio=$(echo "scale=2 ; $height / 1350" | bc)
            heightRatio=$(echo "$heightRatio * 100 / 1" | bc)

            echo -n -e "\e[93mConverting... \e[0m"

            if [ "$watermarking" = true ] # Boolean check
            then
                outputFile="$filename-insta-4x5-nocrop-wm.jpg"
            else
                outputFile="$filename-insta-4x5-nocrop.jpg"
            fi

            # Add white borders to the left and right (double brackets to activate the aritmetic context)
            if (( widthRatio < heightRatio ))
            then
                if [ "$watermarking" = true ] # Boolean check
                then
                    # First resize to picture with HEIGHT of 1350 (x1350), then watermark, then add borders
                    convert -quality 100 "$filepath" \
                        -resize x1350 \
                        -pointsize 25 -font "$fontLocation" -kerning 1.01 -fill $watermarkColor \
                        -gravity SouthWest -annotate +30+40 "$watermarkText" +repage \
                        -gravity center -background white -extent '1080x1350' "$outputFile"
                else
                    convert -quality 100 "$filepath" -resize x1350 -gravity center -background white -extent '1080x1350' "$outputFile"
                fi

            # Add white border to the top and bottom
            else
                if [ "$watermarking" = true ] # Boolean check
                then
                    # First resize to picture with WIDTH of 1080, then watermark, then add borders
                    convert -quality 100 "$filepath" \
                        -resize 1080 \
                        -pointsize 25 -font "$fontLocation" -kerning 1.01 -fill $watermarkColor \
                        -gravity SouthWest -annotate +38+20 "$watermarkText" +repage \
                        -gravity center -background white -extent '1080x1350' "$outputFile"
                else
                    convert -quality 100 "$filepath" -resize 1080 -gravity center -background white -extent '1080x1350' "$outputFile"
                fi
            fi
            ;;

        # Insta 2x(4:5) [2160x1350] (divide in two halves)
        10)
            # Check if the aspect ratio's match and ask for a "gravity" option if not the case
            checkAspectRatio $width $height 2160 1350

            echo -n -e "\e[93mConverting... \e[0m"

            if [ "$watermarking" = true ] # Boolean check
            then
                outputFile="$filename-insta-4x5-wide-wm.jpg"

                # First resize to big picture, then divide in two, then watermark 
                # "@" = Equally divide the image into the number of tiles generated
                # "+gravity" = reset gravity option
                convert -quality 100 "$filepath" \
                    -resize '2160x1350^' -gravity $selectedGravity -crop '2160x1350+0+0' +repage \
                    +gravity -crop 2x1@ +repage \
                    -pointsize 30 -font "$fontLocation" -kerning 1.01 -fill $watermarkColor \
                    -gravity SouthWest -annotate +9+4 "$watermarkText" "$outputFile"
            else
                outputFile="$filename-insta-4x5-wide.jpg"

                convert -quality 100 "$filepath" -resize '2160x1350^' -gravity $selectedGravity \
                    -crop '2160x1350+0+0' +repage +gravity -crop 2x1@ +repage "$outputFile"
            fi
            ;;

        # Insta (5:4) [1080x566]
        11)
            # Check if the aspect ratio's match and ask for a "gravity" option if not the case
            checkAspectRatio $width $height 1080 566

            echo -n -e "\e[93mConverting... \e[0m"

            if [ "$watermarking" = true ] # Boolean check
            then
                outputFile="$filename-insta-5x4-wm.jpg"

                convert -quality 100 "$filepath" \
                    -resize '1080x566^' -gravity $selectedGravity -crop '1080x566+0+0' +repage \
                    -pointsize 30 -font "$fontLocation" -kerning 1.01 -fill $watermarkColor \
                    -gravity SouthWest -annotate +9+4 "$watermarkText" "$outputFile"
            else
                outputFile="$filename-insta-5x4.jpg"

                convert -quality 100 "$filepath" -resize '1080x566^' -gravity $selectedGravity -crop '1080x566+0+0' "$outputFile"
            fi
            ;;

        # 35mm (3:2) [NA] (no watermark)
        12)
            # Check if the aspect ratio's match and ask for a "gravity" option if not the case
            checkAspectRatio $width $height 3 2

            echo -n -e "\e[93mConverting ... \e[0m"

            outputFile="$filename-3x2.jpg"

            convert -quality 100 "$filepath" -gravity $selectedGravity -crop 3:2 "$outputFile"
            ;;

        # 35mm (2:3) [NA] (no watermark)
        13)
            # Check if the aspect ratio's match and ask for a "gravity" option if not the case
            checkAspectRatio $width $height 2 3

            echo -n -e "\e[93mConverting ... \e[0m"

            outputFile="$filename-2x3.jpg"

            convert -quality 100 "$filepath" -gravity $selectedGravity -crop 2:3 "$outputFile"
            ;;

        # Unknown option
        *)
            echo -e "\e[91mERROR: Unknown option selected. Goodbye!\e[0m\n"
            ;;
    esac

    if [ "$option" = '' ] || [ "$option" = '0'  ] || [ "$option" = '1'  ] || [ "$option" = '2'  ] || [ "$option" = '3'  ] || [ "$option" = '4' ] \
                          || [ "$option" = '5'  ] || [ "$option" = '6'  ] || [ "$option" = '7'  ] || [ "$option" = '8'  ] || [ "$option" = '9' ] \
                          || [ "$option" = '10' ] || [ "$option" = '11' ] || [ "$option" = '12' ] || [ "$option" = '13' ]
    then
        echo -e "\e[93mDone! Created file: \e[0m$outputFile\n"
    fi
}


# ================== #
# MAIN FUNCTION CALL #
# ================== #

# Explicitly passing "$@" to main is required to make the command line arguments of the script visible in the function
main "$@"
